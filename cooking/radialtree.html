<!DOCTYPE html>
<meta charset="utf-8">
<head>
<style>
body {
  padding: 0px;
  margin: 0px;
  overflow: hidden;
}

svg text {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

svg text::selection {
  background: none;
}

g > text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.level-0 {
  opacity: 0;
}

.cookie-syncing-third-parties {
  fill: none;
  stroke: yellow;
  stroke-width: 1px;
}

.common-third-parties {
  fill: none;
  stroke: blue;
  stroke-width: 1px;
}

.common-third-parties-sharing-cookies {
  fill: none;
  stroke: lime;
  stroke-width: 1px;
}

.third-parties-sharing-cookies {
  fill: none;
  stroke: red;
  stroke-width: 1px;
}

.third-parties-sharing-cookies-via-url {
  fill: none;
  stroke: magenta;
  stroke-width: 1px;
}

.toolbox {
  position: absolute;
}
</style>
</head>
<body>
  <div id='tooltip_container'></div>
  <div id='toolbox_container' class='toolbox'>
    <input type="checkbox" id="checkboxSameDomain"><span style='background-color:blue'>Same domain</span></input><br>
    <input type="checkbox" id="checkboxSameCookie"><span style='background-color:red'>Same Cookie param</span></input><br>
    <input type="checkbox" id="checkboxSameDomainCookie"><span style='background-color:lime'>Same Domain &amp; Same Cookie param</span></input><br>
    <input type="checkbox" id="checkboxSameCookieInURL"><span style='background-color:magenta'>Same Cookie param in URL</span></input><br>
    <input type="checkbox" id="checkboxCookieSync"><span style='background-color:yellow'>Same Cookie Param in URL for the same website</span></input><br>
    <button id="downloadButton">Download</button>
  </div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
function diagonal(s, d)
  {
    return `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`
}

var tooltip = d3.select('#tooltip_container')
  .append("div")
  .style("opacity", 0)
  .style("position", "absolute")
  .style("background-color", "white")
  .style("border", "solid")
  .style("border-width", "2px")
  .style("border-radius", "5px")
  .style("padding", "5px")
  .style("user-select", "none")

const mouseover = function(d) {
  if (!d.data.value || !d.depth)
    return;

  tooltip.style("opacity", 1);
//  d3.select(this).style("stroke", "yellow")
};

const mousemove = function(d) {
  if (!d.data.value || !d.depth)
    return;

  tooltip.html(d.data.value.replaceAll('\n', '<br>'))
    .style("left", (d3.event.pageX + 1) + "px")
    .style("top", (d3.event.pageY + 1) + "px")
};

const mouseleave = function(d) {
  if (!d.data.value || !d.depth)
    return;

  tooltip.style("opacity", 0)
//  d3.select(this).style("stroke", "none")
};

const svg = d3.select('body')
  .append("svg")
  .attr("width", "100%")
  .attr("height", `${window.innerHeight}px`)
  .call(d3.zoom().on("zoom", function () {
    svg.attr("transform", d3.event.transform)
  }))
  .append("g");

const radius = window.innerHeight / 2 - 50;
const tree = d3.tree()
  .size([2 * Math.PI, radius])
  .separation((a, b) => (a.parent == b.parent ? 1 : 2) / a.depth);

d3.json("data.json", function(error, data) {
  if (error)
    throw error;

  const gNode = svg.append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all')

  const gLink = svg.append("g")
    .attr("fill", "none")
    .attr("stroke", "#555")
    .attr("stroke-opacity", 0.4)
    .attr("stroke-width", 1.5);

  const gCrossLinkForSameDomain = svg.append('g')
    .attr('class', 'common-third-parties')

  const gCrossLinkForSameCookie = svg.append('g')
    .attr('class', 'third-parties-sharing-cookies')

  const gCrossLinkForSameCookieInURL = svg.append('g')
    .attr('class', 'third-parties-sharing-cookies-via-url')

  const gCrossLinkForSameDomainCookie = svg.append('g')
    .attr('class', 'common-third-parties-sharing-cookies')

  const gLinkForSameCookieInURL = svg.append('g')
    .attr('class', 'cookie-syncing-third-parties')

  var root = d3.hierarchy(data)
    .sort((a, b) => d3.ascending(a.data.name, b.data.name));

  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth && d.depth > 1)
        d.children = null;
  });
  root.x0 = 0;
  root.y0 = 0;

  var sourceNode = root;
  var crossLinksSharingDomain = [];
  var crossLinksSharingCookie = [];
  var crossLinksSharingCookieInURL = [];
  var crossLinksSharingDomainAndCookie = [];

  var crossPairsForSameDomain = [];
  var crossPairsForSameCookie = [];
  var crossPairsForSameCookieInURL = [];
  var crossPairsForSameDomainCookie = [];
  var crossPairsForSameCookieDifferentDomain = [];
  var crossPairsForSameDomainDifferentCookie = [];

  // To show Cookie Sync
  var aLinksSharingCookieInURL = [];
  var bLinksSharingCookieInURL = [];

  var aPairsForSameCookieInURL = [];
  var bPairsForSameCookieInURL = [];


  d3.select("#checkboxSameDomain")
    .on("change", () => {
      update(sourceNode);
    });
  d3.select("#checkboxSameCookie")
    .on("change", () => {
      update(sourceNode);
    });
  d3.select("#checkboxSameDomainCookie")
    .on("change", () => {
      update(sourceNode);
    });
  d3.select("#checkboxSameCookieInURL")
    .on("change", () => {
      update(sourceNode);
    });
  d3.select("#checkboxCookieSync")
    .on("change", () => {
      update(sourceNode);
    });
  d3.select("#downloadButton")
    .on("click", () => {
      download();
    });

  update(root);
  //draw(root.descendants()[2]);

  function update(source) {
      const duration = d3.event && d3.event.altKey ? 2500 : 250;
      const nodes = root.descendants().reverse();
      const links = root.links();

      root = tree(root);

      /* Link update */
      const link = gLink.selectAll("path")
        .data(links, d => d.target.id)

      const linkEnter = link.enter().append("path")
        .attr("class", d => `level-${d.source.depth}`)
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
        `)
        .attr("d", d3.linkRadial()
          .angle(d => source.x)
          .radius(d => source.y));

      link.merge(linkEnter).transition()
        .duration(duration)
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
        `)
        .attr("d", d3.linkRadial()
          .angle(d => d.x)
          .radius(d => d.y));

      link.exit().transition()
        .duration(duration)
        .remove()
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
        `)
        .attr("d", d3.linkRadial()
          .angle(d => source.x)
          .radius(d => source.y));


      /* Node update */
      const node = gNode.selectAll("g")
        .data(nodes, d => d.id);

      const nodeEnter = node.enter().append("g")
        .attr("class", d => `level-${d.depth}`)
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
          rotate(${d.x * 180 / Math.PI - 90})
          translate(${source.y0}, ${source.x0})
          rotate(${d.x >= Math.PI ? 180 : 0})
        `)
        .attr("fill-opacity", 0)
        .attr("stroke-opacity", 0)
        .on("click", (d) => {
          if (!d.depth) {
            source = d;
            update(d);
            return;
          }

          if (!d.children) {
              d.children = d._children;
              d._children = null;
          } else
              collapse(d);

          source = d;
          update(d);
        })
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)

      nodeEnter.append("circle")
        .attr("r", 2.5)
        .attr("fill", d => d._children ? "#555" : "#999")
        .attr("stroke-width", 10);

      nodeEnter.append("text")
        .attr("font-family", "sans-serif")
        .attr("font-size", 10)
        .attr("stroke-linejoin", "round")
        .attr("stroke-width", 3)
        .attr("dy", "0.31em")
//        .attr("x", d => d._children ? -6 : 6)
//        .attr("text-anchor", d => d._children ? "end" : "start")
        .attr("text-anchor", d => d.x < Math.PI === !d.children ? "end" : "start")
        .attr("x", d => d.x < Math.PI === !d.children ? -6 : 6)
        .text(d => d.data.name)
        .clone(true).lower()
        .attr("stroke", "white")

      const nodeUpdate = node.merge(nodeEnter).transition()
        .duration(duration)
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
          rotate(${d.x * 180 / Math.PI - 90})
          translate(${d.y}, 0)
          rotate(${d.x >= Math.PI ? 180 : 0})
        `)
        .attr("fill-opacity", 1)
        .attr("stroke-opacity", 1)

      const nodeExit = node.exit().transition()
        .duration(duration)
        .remove()
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
          rotate(${d.x * 180 / Math.PI - 90})
          translate(${source.y}, ${source.x})
        `)
        .attr("fill-opacity", 1)
        .attr("stroke-opacity", 0);


      root.eachBefore(d => {
        d.x0 = d.x;
        d.y0 = d.y;
      });


      crossLinksSharingDomain.forEach(pair => {
        pair.remove();
      });
      crossLinksSharingDomain = []

      crossLinksSharingCookie.forEach(pair => {
        pair.remove();
      });
      crossLinksSharingCookie = []

      crossLinksSharingCookieInURL.forEach(pair => {
        pair.remove();
      });
      crossLinksSharingCookieInURL = []

      crossLinksSharingDomainAndCookie.forEach(pair => {
        pair.remove();
      });
      crossLinksSharingDomainAndCookie = []

      aLinksSharingCookieInURL.forEach(pair => {
        pair.remove();
      });
      aLinksSharingCookieInURL = []

      bLinksSharingCookieInURL.forEach(pair => {
        pair.remove();
      });
      bLinksSharingCookieInURL = []


      const domainNodesSetA = root['children'][0].descendants().filter(d => d.depth === 2);
      const domainNodesSetB = root['children'][1].descendants().filter(d => d.depth === 2);

      // Cookie syncing pairs for domain set A
      for (let i = 0; i < domainNodesSetA.length - 1; ++i) {
        const domainNode1 = domainNodesSetA[i];
        for (let j = i + 1; j < domainNodesSetA.length; ++j) {
          const domainNode2 = domainNodesSetA[j];

          domainNode1.data['children'].forEach(subdomain1 => {
            subdomain1['children'].forEach(path1 => {
              path1['children'].forEach(http1 => {
                http1['children'][0]['cookies'].forEach(cookie1 => {
                  domainNode2.data['children'].forEach(subdomain2 => {
                    subdomain2['children'].forEach(path2 => {
                      path2['children'].forEach(http2 => {
                        let reason = [];
                        let result = false;
                        http2['children'][0]['cookies'].forEach(cookie2 => {
                          const cookieName1 = cookie1['name'].toLowerCase()
                          const cookieName2 = cookie2['name'].toLowerCase()
                          const cookieValue1 = cookie1['value'].toLowerCase()
                          const cookieValue2 = cookie2['value'].toLowerCase()

                          if (http1['children'][0]['queries'].some(q => q['name'].includes('id') && q['value'] === cookieValue2)) {
                            reason.push({
                              cookies: [{name: cookie2['name'], value: cookie2['value']}],
                              queries: http1['children'][0]['queries'],
                            });
                            result = true;
                          }

                          if (http2['children'][0]['queries'].some(q => q['name'].includes('id') && q['value'] === cookieValue1)) {
                            reason.push({
                              cookies: [{name: cookie1['name'], value: cookie1['value']}],
                              queries: http2['children'][0]['queries'],
                            });
                            result = true;
                          }
                        })

                        if (result)
                          aPairsForSameCookieInURL.push({source: domainNode1, target: domainNode2, reason: reason});
                      })
                    })
                  })
                })
              })
            })
          })
        }
      }

      // Cookie syncing pairs for domain set B
      for (let i = 0; i < domainNodesSetB.length - 1; ++i) {
        const domainNode1 = domainNodesSetB[i];
        for (let j = i + 1; j < domainNodesSetB.length; ++j) {
          const domainNode2 = domainNodesSetB[j];

          domainNode1.data['children'].forEach(subdomain1 => {
            subdomain1['children'].forEach(path1 => {
              path1['children'].forEach(http1 => {
                http1['children'][0]['cookies'].forEach(cookie1 => {
                  domainNode2.data['children'].forEach(subdomain2 => {
                    subdomain2['children'].forEach(path2 => {
                      path2['children'].forEach(http2 => {
                        let reason = [];
                        let result = false;
                        http2['children'][0]['cookies'].forEach(cookie2 => {
                          const cookieName1 = cookie1['name'].toLowerCase()
                          const cookieName2 = cookie2['name'].toLowerCase()
                          const cookieValue1 = cookie1['value'].toLowerCase()
                          const cookieValue2 = cookie2['value'].toLowerCase()

                          if (http1['children'][0]['queries'].some(q => q['name'].includes('id') && q['value'] === cookieValue2)) {
                            reason.push({
                              cookies: [{name: cookie2['name'], value: cookie2['value']}],
                              queries: http1['children'][0]['queries'],
                            });
                            result = true;
                          }

                          if (http2['children'][0]['queries'].some(q => q['name'].includes('id') && q['value'] === cookieValue1)) {
                            reason.push({
                              cookies: [{name: cookie1['name'], value: cookie1['value']}],
                              queries: http2['children'][0]['queries'],
                            });
                            result = true;
                          }

                        })

                        if (result)
                          bPairsForSameCookieInURL.push({source: domainNode1, target: domainNode2, reason: reason});
                      })
                    })
                  })
                })
              })
            })
          })
        }
      }

      crossPairsForSameDomain = []
      domainNodesSetA.forEach(nodeA => {
        domainNodesSetB.forEach(nodeB => {
          let reason = [];
          if (nodeA.data['name'] == nodeB.data['name']) {
            reason.push(nodeA.data['name'])
            crossPairsForSameDomain.push({source: nodeA, target: nodeB, reason: reason});
          }
        });
      });


      crossPairsForSameCookie = []
      crossPairsForSameCookieInURL = []
      domainNodesSetA.forEach(d1 => {
        d1.data['children'].forEach(subdomain1 => {
          subdomain1['children'].forEach(path1 => {
            path1['children'].forEach(http1 => {
              http1['children'][0]['cookies'].forEach(cookie1 => {
                domainNodesSetB.forEach(d2 => {
                  d2.data['children'].forEach(subdomain2 => {
                    subdomain2['children'].forEach(path2 => {
                      path2['children'].forEach(http2 => {
                          let reason = [];
                          let result = false;
                          http2['children'][0]['cookies'].forEach(cookie2 => {
                            const cookieName1 = cookie1['name'].toLowerCase()
                            const cookieName2 = cookie2['name'].toLowerCase()
                            const cookieValue1 = cookie1['value'].toLowerCase()
                            const cookieValue2 = cookie2['value'].toLowerCase()
                            if ((cookieName1 === cookieName2
                                || (cookieName1.includes('id') && cookieName2.includes('id')))
                                && cookieValue1 === cookieValue2) {
                              reason.push({
                                cookies: [{name: cookie1['name'], value: cookie1['value']}, {name: cookie2['name'], value: cookie2['value']}]
                              });
                              result = true;
                            }
                          })
                          if (result)
                            crossPairsForSameCookie.push({source: d1, target: d2, reason: reason});

                          reason = [];
                          result = false;
                          http2['children'][0]['cookies'].forEach(cookie2 => {
                            const cookieName1 = cookie1['name'].toLowerCase()
                            const cookieName2 = cookie2['name'].toLowerCase()
                            const cookieValue1 = cookie1['value'].toLowerCase()
                            const cookieValue2 = cookie2['value'].toLowerCase()

                            if (http1['children'][0]['queries'].some(q => q['name'].includes('id') && q['value'] === cookieValue2)) {
                              reason.push({
                                cookies: [{name: cookie2['name'], value: cookie2['value']}],
                                queries: http1['children'][0]['queries'],
                              });
                              result = true;
                            }

                            if (http2['children'][0]['queries'].some(q => q['name'].includes('id') && q['value'] === cookieValue1)) {
                              reason.push({
                                cookies: [{name: cookie1['name'], value: cookie1['value']}],
                                queries: http2['children'][0]['queries'],
                              });
                              result = true;
                            }
                          })

                          if (result)
                            crossPairsForSameCookieInURL.push({source: d1, target: d2, reason: reason});
                      })
                    })
                  })
                })
              })
            })
          })
        })
      });

      crossPairsForSameCookie = crossPairsForSameCookie.filter((pair, index, self) =>
        index === self.findIndex((t) => (
          t.source.data.name === pair.source.data.name
            && t.target.data.name === pair.target.data.name
        ))
      )

      crossPairsForSameCookieInURL = crossPairsForSameCookieInURL.filter((pair, index, self) =>
        index === self.findIndex((t) => (
          t.source.data.name === pair.source.data.name
            && t.target.data.name === pair.target.data.name
        ))
      )

      aPairsForSameCookieInURL = aPairsForSameCookieInURL.filter((pair, index, self) =>
        index === self.findIndex((t) => (
          t.source.data.name === pair.source.data.name
            && t.target.data.name === pair.target.data.name
        ))
      )

      bPairsForSameCookieInURL = bPairsForSameCookieInURL.filter((pair, index, self) =>
        index === self.findIndex((t) => (
          t.source.data.name === pair.source.data.name
            && t.target.data.name === pair.target.data.name
        ))
      )

      crossPairsForSameDomainCookie = crossPairsForSameCookie.filter(pair => pair.source.data.name === pair.target.data.name)
      crossPairsForSameCookieDifferentDomain = crossPairsForSameCookie.filter(pair => pair.source.data.name !== pair.target.data.name)
      crossPairsForSameDomainDifferentCookie = crossPairsForSameDomain.filter(pair1 => {
          return !crossPairsForSameDomainCookie.some(pair2 => pair2.source.data.name === pair1.source.data.name && pair2.target.data.name === pair1.target.data.name);
      });

      const sameDomainChecked = d3.select("#checkboxSameDomain").property("checked");
      const sameCookieChecked = d3.select("#checkboxSameCookie").property("checked");
      const sameDomainCookieChecked = d3.select("#checkboxSameDomainCookie").property("checked");
      const sameCookieInURLChecked = d3.select("#checkboxSameCookieInURL").property("checked");
      const cookieSyncChecked = d3.select("#checkboxCookieSync").property("checked");

      if (sameDomainCookieChecked || (sameDomainChecked && sameCookieChecked)) {
        crossPairsForSameDomainCookie.forEach(pair => {
          const p = gCrossLinkForSameDomainCookie.append("path")
            .attr("transform", d => `
              translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
            `)
            .attr('d', d3.linkRadial()
              .source(d => pair.source)
              .target(d => pair.target)
              .angle(d => d.x0)
              .radius(d => d.y0))

          crossLinksSharingDomainAndCookie.push(p);
        });

        if (sameDomainChecked) {
          crossPairsForSameDomainDifferentCookie.forEach(pair => {
            const p = gCrossLinkForSameDomain.append("path")
              .attr("transform", d => `
                translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
              `)
              .attr('d', d3.linkRadial()
                .source(d => pair.source)
                .target(d => pair.target)
                .angle(d => d.x0)
                .radius(d => d.y0))

            crossLinksSharingDomain.push(p);
          });
        }

        if (sameCookieChecked) {
          crossPairsForSameCookieDifferentDomain.forEach(pair => {
            const p = gCrossLinkForSameCookie.append("path")
              .attr("transform", d => `
                translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
              `)
              .attr('d', d3.linkRadial()
                .source(d => pair.source)
                .target(d => pair.target)
                .angle(d => d.x0)
                .radius(d => d.y0))

            crossLinksSharingCookie.push(p);
          });
        }
      } else {
        if (sameDomainChecked) {
          crossPairsForSameDomain.forEach(pair => {
            const p = gCrossLinkForSameDomain.append("path")
              .attr("transform", d => `
                translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
              `)
              .attr('d', d3.linkRadial()
                .source(d => pair.source)
                .target(d => pair.target)
                .angle(d => d.x0)
                .radius(d => d.y0))

            crossLinksSharingDomain.push(p);
          });
        }

        if (sameCookieChecked) {
          crossPairsForSameCookie.forEach(pair => {
            const p = gCrossLinkForSameCookie.append("path")
              .attr("transform", d => `
                translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
              `)
              .attr('d', d3.linkRadial()
                .source(d => pair.source)
                .target(d => pair.target)
                .angle(d => d.x0)
                .radius(d => d.y0))

            crossLinksSharingCookie.push(p);
          });
        }
      }

      if (sameCookieInURLChecked) {
        crossPairsForSameCookieInURL.forEach(pair => {
          const p = gCrossLinkForSameCookieInURL.append("path")
            .attr("transform", d => `
              translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
            `)
            .attr('d', d3.linkRadial()
              .source(d => pair.source)
              .target(d => pair.target)
              .angle(d => d.x0)
              .radius(d => d.y0))

          crossLinksSharingCookieInURL.push(p);
        });
      }

      if (cookieSyncChecked) {
        aPairsForSameCookieInURL.forEach(pair => {
          const p = gLinkForSameCookieInURL.append("path")
            .attr("transform", d => `
              translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
            `)
            .attr('d', d3.linkRadial()
              .source(d => pair.source)
              .target(d => pair.target)
              .angle(d => d.x0)
              .radius(d => d.y0))

          aLinksSharingCookieInURL.push(p);
        });

        bPairsForSameCookieInURL.forEach(pair => {
          const p = gLinkForSameCookieInURL.append("path")
            .attr("transform", d => `
              translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
            `)
            .attr('d', d3.linkRadial()
              .source(d => pair.source)
              .target(d => pair.target)
              .angle(d => d.x0)
              .radius(d => d.y0))

          bLinksSharingCookieInURL.push(p);
        });
      }
    }

    function draw(root) {
      root = tree(root);
      svg.append("g")
        .selectAll("circle")
        .data(root.descendants())
        .enter().append("circle")
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
          rotate(${d.x * 180 / Math.PI - 90})
          translate(${d.y},0)
        `)
        .attr("fill", d => d.children ? "#555" : "#999")
        .attr("r", 2.5);

      svg.append("g")
        .attr("font-family", "sans-serif")
        .attr("font-size", 10)
        .attr("stroke-linejoin", "round")
        .attr("stroke-width", 3)
        .selectAll("text")
        .data(root.descendants())
        .enter().append("text")
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
          rotate(${d.x * 180 / Math.PI - 90})
          translate(${d.y},0)
          rotate(${d.x >= Math.PI ? 180 : 0})
        `)
        .attr("dy", "0.31em")
        .attr("x", d => d.x < Math.PI === !d.children ? 6 : -6)
        .attr("text-anchor", d => d.x < Math.PI === !d.children ? "start" : "end")
        .text(d => d.data.name)
        .clone(true).lower()
        .attr("stroke", "white");

      svg.append("g")
        .attr("fill", "none")
        .attr("stroke", "#555")
        .attr("stroke-opacity", 0.4)
        .attr("stroke-width", 1.5)
        .selectAll("path")
        .data(root.links())
        .enter().append("path")
        .attr("transform", d => `
          translate(${window.innerWidth / 2}, ${window.innerHeight / 2})
        `)
        .attr("d", d3.linkRadial()
        .angle(d => d.x)
        .radius(d => d.y));
    }

    function collapse(d) {
      if(d.children) {
        d._children = d.children
        d._children.forEach(collapse)
        d.children = null
      }
    }

    function download() {
      let jsonData = {};

      const sameDomainChecked = d3.select("#checkboxSameDomain").property("checked");
      const sameCookieChecked = d3.select("#checkboxSameCookie").property("checked");
      const sameDomainCookieChecked = d3.select("#checkboxSameDomainCookie").property("checked");
      const sameCookieInURLChecked = d3.select("#checkboxSameCookieInURL").property("checked");
      const cookieSyncChecked = d3.select("#checkboxCookieSync").property("checked");

      if (sameDomainCookieChecked || (sameDomainChecked && sameCookieChecked)) {
        jsonData['same-domain-cookie'] = [];
        crossPairsForSameDomainCookie.forEach(pair => {
          jsonData['same-domain-cookie'].push({
            reason: pair.reason,
            nodeA: pair.source.data,
            nodeB: pair.target.data,
          })
        });

        if (sameDomainChecked) {
          jsonData['same-domain-different-cookie'] = [];
          crossPairsForSameDomainDifferentCookie.forEach(pair => {
            jsonData['same-domain-different-cookie'].push({
              reason: pair.reason,
              nodeA: pair.source.data,
              nodeB: pair.target.data,
            })
          });
        }

        if (sameCookieChecked) {
          jsonData['same-cookie-different-domain'] = [];
          crossPairsForSameCookieDifferentDomain.forEach(pair => {
            jsonData['same-cookie-different-domain'].push({
              reason: pair.reason,
              nodeA: pair.source.data,
              nodeB: pair.target.data,
            })
          });
        }
      } else {
        if (sameDomainChecked) {
          jsonData['same-domain'] = [];
          crossPairsForSameDomain.forEach(pair => {
            jsonData['same-domain'].push({
              reason: pair.reason,
              nodeA: pair.source.data,
              nodeB: pair.target.data,
            })
          });
        }

        if (sameCookieChecked) {
          jsonData['same-cookie'] = [];
          crossPairsForSameCookie.forEach(pair => {
            jsonData['same-cookie'].push({
              reason: pair.reason,
              nodeA: pair.source.data,
              nodeB: pair.target.data,
            })
          });
        }
      }

      if (sameCookieInURLChecked) {
        jsonData['same-cookie-in-url'] = [];
        crossPairsForSameCookieInURL.forEach(pair => {
          jsonData['same-cookie-in-url'].push({
            reason: pair.reason,
            nodeA: pair.source.data,
            nodeB: pair.target.data,
          })
        });
      }

      if (cookieSyncChecked) {
        jsonData['cookie-sync'] = [];
        aPairsForSameCookieInURL.forEach(pair => {
          jsonData['cookie-sync'].push({
            reason: pair.reason,
            nodeA: pair.source.data,
            nodeB: pair.target.data,
          })
        });
        bPairsForSameCookieInURL.forEach(pair => {
          jsonData['cookie-sync'].push({
            reason: pair.reason,
            nodeA: pair.source.data,
            nodeB: pair.target.data,
          })
        });
      }

      if (Object.keys(jsonData).length === 0 && jsonData.constructor === Object)
        return;

      const aElement = document.createElement("a");
      const file = new Blob([JSON.stringify(jsonData, null, 2)], {type: 'text/plain'});
      aElement.href = URL.createObjectURL(file);
      aElement.download = `radialtree.json`;
      document.body.appendChild(aElement); // Necessary for Firefox
      aElement.click();
      document.body.removeChild(aElement);
    }
});

</script>
</html>
